import sys
S_box = [
        [
                0xe, 0x4, 0xd, 0x1, 0x2, 0xf, 0xb, 0x8, 0x3, 0xa, 0x6, 0xc, 0x5, 0x9, 0x0, 0x7,
                0x0, 0xf, 0x7, 0x4, 0xe, 0x2, 0xd, 0x1, 0xa, 0x6, 0xc, 0xb, 0x9, 0x5, 0x3, 0x8,
                0x4, 0x1, 0xe, 0x8, 0xd, 0x6, 0x2, 0xb, 0xf, 0xc, 0x9, 0x7, 0x3, 0xa, 0x5, 0x0,
                0xf, 0xc, 0x8, 0x2, 0x4, 0x9, 0x1, 0x7, 0x5, 0xb, 0x3, 0xe, 0xa, 0x0, 0x6, 0xd,
        ],
        [
                0xf, 0x1, 0x8, 0xe, 0x6, 0xb, 0x3, 0x4, 0x9, 0x7, 0x2, 0xd, 0xc, 0x0, 0x5, 0xa,
                0x3, 0xd, 0x4, 0x7, 0xf, 0x2, 0x8, 0xe, 0xc, 0x0, 0x1, 0xa, 0x6, 0x9, 0xb, 0x5,
                0x0, 0xe, 0x7, 0xb, 0xa, 0x4, 0xd, 0x1, 0x5, 0x8, 0xc, 0x6, 0x9, 0x3, 0x2, 0xf,
                0xd, 0x8, 0xa, 0x1, 0x3, 0xf, 0x4, 0x2, 0xb, 0x6, 0x7, 0xc, 0x0, 0x5, 0xe, 0x9,
        ],
        [
                0xa, 0x0, 0x9, 0xe, 0x6, 0x3, 0xf, 0x5, 0x1, 0xd, 0xc, 0x7, 0xb, 0x4, 0x2, 0x8,
                0xd, 0x7, 0x0, 0x9, 0x3, 0x4, 0x6, 0xa, 0x2, 0x8, 0x5, 0xe, 0xc, 0xb, 0xf, 0x1,
                0xd, 0x6, 0x4, 0x9, 0x8, 0xf, 0x3, 0x0, 0xb, 0x1, 0x2, 0xc, 0x5, 0xa, 0xe, 0x7,
                0x1, 0xa, 0xd, 0x0, 0x6, 0x9, 0x8, 0x7, 0x4, 0xf, 0xe, 0x3, 0xb, 0x5, 0x2, 0xc,
        ],
        [
                0x7, 0xd, 0xe, 0x3, 0x0, 0x6, 0x9, 0xa, 0x1, 0x2, 0x8, 0x5, 0xb, 0xc, 0x4, 0xf,
                0xd, 0x8, 0xb, 0x5, 0x6, 0xf, 0x0, 0x3, 0x4, 0x7, 0x2, 0xc, 0x1, 0xa, 0xe, 0x9,
                0xa, 0x6, 0x9, 0x0, 0xc, 0xb, 0x7, 0xd, 0xf, 0x1, 0x3, 0xe, 0x5, 0x2, 0x8, 0x4,
                0x3, 0xf, 0x0, 0x6, 0xa, 0x1, 0xd, 0x8, 0x9, 0x4, 0x5, 0xb, 0xc, 0x7, 0x2, 0xe,
        ],
        [
                0x2, 0xc, 0x4, 0x1, 0x7, 0xa, 0xb, 0x6, 0x8, 0x5, 0x3, 0xf, 0xd, 0x0, 0xe, 0x9,
                0xe, 0xb, 0x2, 0xc, 0x4, 0x7, 0xd, 0x1, 0x5, 0x0, 0xf, 0xa, 0x3, 0x9, 0x8, 0x6,
                0x4, 0x2, 0x1, 0xb, 0xa, 0xd, 0x7, 0x8, 0xf, 0x9, 0xc, 0x5, 0x6, 0x3, 0x0, 0xe,
                0xb, 0x8, 0xc, 0x7, 0x1, 0xe, 0x2, 0xd, 0x6, 0xf, 0x0, 0x9, 0xa, 0x4, 0x5, 0x3,
        ],
        [
                0xc, 0x1, 0xa, 0xf, 0x9, 0x2, 0x6, 0x8, 0x0, 0xd, 0x3, 0x4, 0xe, 0x7, 0x5, 0xb,
                0xa, 0xf, 0x4, 0x2, 0x7, 0xc, 0x9, 0x5, 0x6, 0x1, 0xd, 0xe, 0x0, 0xb, 0x3, 0x8,
                0x9, 0xe, 0xf, 0x5, 0x2, 0x8, 0xc, 0x3, 0x7, 0x0, 0x4, 0xa, 0x1, 0xd, 0xb, 0x6,
                0x4, 0x3, 0x2, 0xc, 0x9, 0x5, 0xf, 0xa, 0xb, 0xe, 0x1, 0x7, 0x6, 0x0, 0x8, 0xd,
        ],
        [
                0x4, 0xb, 0x2, 0xe, 0xf, 0x0, 0x8, 0xd, 0x3, 0xc, 0x9, 0x7, 0x5, 0xa, 0x6, 0x1,
                0xd, 0x0, 0xb, 0x7, 0x4, 0x9, 0x1, 0xa, 0xe, 0x3, 0x5, 0xc, 0x2, 0xf, 0x8, 0x6,
                0x1, 0x4, 0xb, 0xd, 0xc, 0x3, 0x7, 0xe, 0xa, 0xf, 0x6, 0x8, 0x0, 0x5, 0x9, 0x2,
                0x6, 0xb, 0xd, 0x8, 0x1, 0x4, 0xa, 0x7, 0x9, 0x5, 0x0, 0xf, 0xe, 0x2, 0x3, 0xc,
        ],
        [
                0xd, 0x2, 0x8, 0x4, 0x6, 0xf, 0xb, 0x1, 0xa, 0x9, 0x3, 0xe, 0x5, 0x0, 0xc, 0x7,
                0x1, 0xf, 0xd, 0x8, 0xa, 0x3, 0x7, 0x4, 0xc, 0x5, 0x6, 0xb, 0x0, 0xe, 0x9, 0x2,
                0x7, 0xb, 0x4, 0x1, 0x9, 0xc, 0xe, 0x2, 0x0, 0x6, 0xa, 0xd, 0xf, 0x3, 0x5, 0x8,
                0x2, 0x1, 0xe, 0x7, 0x4, 0xa, 0x8, 0xd, 0xf, 0xc, 0x9, 0x0, 0x3, 0x5, 0x6, 0xb,
        ],
]

P_box = [
        16, 7,20,21,29,12,28,17,
        1 ,15,23,26, 5,18,31,10,
        2 ,8 ,24,14,32,27, 3, 9,
        19,13,30, 6,22,11, 4,25,
]

E_box = [
        32,1,2,3,4,5,
        4,5,6,7,8,9,
        8,9,10,11,12,13,
        12,13,14,15,16,17,
        16,17,18,19,20,21,
        20,21,22,23,24,25,
        24,25,26,27,28,29,
        28,29,30,31,32,1,
]
S_table = [
            [
                [
                    -32 for beta in range(16)
                ]for alpha in range(64)
            ]for i in range(8)
]
trans6 = lambda n: '{:0>6}'.format(bin(n)[2:])    #掩码转换
trans4 = lambda n: '{:0>4}'.format(bin(n)[2:])

def S(i,IN):
    bit6 = trans6(IN)
    location = int(bit6[0]+bit6[-1],2)*16 + int(bit6[1:-1],2)
    return int(S_box[i][location])

def xor(num,wide):
    count=0
    for i in range(wide):
        if (num&1):
            count+=1
        num>>=1
    if(count%2==0):  
        return 0
    return 1         

def get_S_table():   #生成线性分布表
    for i in range(8):
        for alpha in range(64):
            for beta in range(16):
                for x in range(64):
                    if(xor(x & alpha,6)==xor(S(i,x) & beta,4)):
                        S_table[i][alpha][beta] += 1
def print_S_table(num):
    print('\t\t\t\t\tS{}线性分布表'.format(num))
    print('α\β\t',end='')
    for i in range(16):
        print(i,end='\t')
    print('\n')
    count = 0
    for alpha in S_table[num-1]:
        print(count,end='\t\t')
        count +=1
        for NS in alpha:
            print(NS,end='\t')
        print('\n')
def get_trace(num):
    max = [0,0,0]  #(i,j,NS)
    for i in range(1,64):
        for j in range(16):
            if abs(S_table[num][i][j]) > abs(max[2]):#
                max[0],max[1],max[2] = i,j,S_table[num][i][j]#找到线性分布表里最大的i,j，赋值给max
    #print("i=",max[0]," j=",max[1])
    best=[]    #（存储输入掩码，目前最大概率可不可以在当前i找到j与之对应，当前最大概率）
    for i in range(1,64):
        try:
            best.append([i, S_table[num][i].index(max[2]), max[2]])#进行试探，如果有就放到best里然后终止寻找
        except ValueError:
            pass
    #print("max",best)
    print('###########第{}个S盒，找到偏差最高三轮逼近式###########'.format(num+1))
    for item in best:
        a = trans6(item[0])#掩码化
        b = trans4(item[1])#掩码化
        #print("item=",item[1])
        alpha = []
        beta = []
        for i in range(6):
            if a[i]=='1':
                alpha.append(num*6+i)   # 此时是左向右计数,从0开始计，掩码位置
        for i in range(4):
            if b[i]=='1':
                beta.append(num*4+i)   # 此时是左向右计数，掩码位置
        #print("b=",b)
        R = []#右输入
        K = []#密钥
        F = []#左输入
        #print("beta_loca=",beta_loca)
        flag=0
        for i in alpha:   #i
            R.append(32 - E_box[i])     # 输入过E扩展
            K.append(47 - i)           #S盒输入对应的轮密钥K的位置
            flag=flag+1
        for i in beta:   #j
            F.append(31-P_box.index(i+1)) #输出过逆p置换 
                    

        print('\tα={},β={},NS={},\t第一轮逼近式：X_2{f}⊕P_H{f}⊕P_L{r}=K1{k}'.format(item[0],item[1],item[-1],r=R,f=F,k=K))
        print('\t三轮总逼近式：P_low{r}⊕P_h{f}⊕C_low{r}⊕C_h{f}=K1{k}⊕K3{k}'.format(r=R,f=F,k=K))
        
        if flag==1:
            get_head(R,max[2],F,K) #R是需要X2构造的序列，max是三轮线路的NS，F1和K1是为了写总表达式
        else:
            print("\t无法构造五轮逼近式")
        
        #print("概率：",(max[2]+32)%32,"/64")
        print()

def get_head(left,p,F1,K1):
    #print("\t构造测试掩码为：",left)
    beta=[]
    for i in left:
        beta.append(P_box[31-i]-1)#yes
    #print("beta",beta)
    num=0;
    bb=[0,0,0,0]
    for k in beta:
        #print("k=",k)
        num=k//4
        bb[(k - num*4)] = 1   #反解S盒序号
    #print("bb=",bb)
    item=0
    for i in range(4):
        if bb[i]==1:
            item += bb[i] * (2 ** (3 - i))
    #print("item=",item)
    max = [0,0,0]  #(i,j,NS)
    for i in range(1,64):
            if abs(S_table[num][i][item]) > abs(max[2]):#
                max[0],max[1],max[2] = i,item,S_table[num][i][item]#找到线性分布表里最大的i,j，赋值给max
    
    best=[]
    best.append([max[0],max[1],max[2]])
    #print("i=",max[0]," j=",max[1])
    

    for item in best:
        a = trans6(item[0])#掩码化
        b = trans4(item[1])#掩码化
        #print("item=",item[1])
        alpha_loca = []
        beta_loca = []
        for i in range(6):
            if a[i]=='1':
                alpha_loca.append(num*6+i)   # 此时是左向右计数,从0开始计，掩码位置
        for i in range(4):
            if b[i]=='1':
                beta_loca.append(num*4+i)   # 此时是左向右计数，掩码位置
        #print("b=",b)
        R_local = []#右输入
        K_local = []#密钥
        F_local = []#左输入
        #print("beta_loca=",beta_loca)
        for i in alpha_loca:   #i
            R_local.append(32 - E_box[i])     # 输入过E扩展
            K_local.append(47 - i)           #S盒输入对应的轮密钥K的位置
            
        for i in beta_loca:   #j
            F_local.append(31-P_box.index(i+1)) #输出过逆p置换 
                
        print('\t新添加头尾部在第{}个S盒'.format(num+1))
        print('\tα={},β={},NS={},\t头尾构造：X_2{f}⊕P_H{f}⊕P_L{r}=K1{k}'.format(item[0],item[1],item[2],r=R_local,f=F_local,k=K_local))
        #print("\tp1=",p,",p2=",max[2])
        for i in F1:   #组成整个P_L比特
            R_local.append(i) #输出过逆p置换    
        
        print('\t五轮总逼近式：P_h{r1}⊕P_l{r}⊕C_h{r1}⊕C_l{r}=K1{k}⊕K2{k1}⊕K4{k1}⊕K5{k}'.format(r=R_local,f=F_local,k=K_local,r1=left,f1=F1,k1=K1))
        print("\t5轮总概率为：",0.5+(2**4)*(p/64)*(max[2]/64)*(p/64)*(max[2]/64)*0.5)
        #print("\t成功率总概率为：",0.5+(2**4)*(p/64)*(max[2]/64)*(p/64)*(max[2]/64)*0.5)
        print()
    
    #print()

if __name__=='__main__':
    get_S_table()
    for i in range(8):
      get_trace(i)    
